Reference commit: 4cf43368f90d221836976987b39a9d4a8564be59

diff --git a/core/src/hyperbolic/scheme/Hyperbolic_WellBalanced_RK2.h b/core/src/hyperbolic/scheme/Hyperbolic_WellBalanced_RK2.h
index aa895dfb..0c8b0bb4 100644
--- a/core/src/hyperbolic/scheme/Hyperbolic_WellBalanced_RK2.h
+++ b/core/src/hyperbolic/scheme/Hyperbolic_WellBalanced_RK2.h
@@ -39,6 +39,7 @@ Hyperbolic_WellBalanced_RK2(
     smallr( configMap.getValue<real_t>("hydro","smallr", 1e-10) ),
     smallp( configMap.getValue<real_t>("hydro","smallp", 1e-10) ),
     smallc( configMap.getValue<real_t>("hydro","smallc", 1e-10) ),
+    smalle( configMap.getValue<real_t>("hydro","smalle", 1e-5) ),
     gamma0( configMap.getValue<real_t>("hydro","gamma0", 1.6666667) ),
     well_balanced_at_boundary( configMap.getValue<bool>("hydro", "well_balanced_at_boundary", false)),
     gravity_enabled( configMap.getValue<GravityType>("gravity", "gravity_type", GRAVITY_NONE) == GRAVITY_CST_SCALAR),
@@ -116,7 +117,6 @@ Hyperbolic_WellBalanced_RK2(
 
     const real_t gamma0 = this->gamma0;
     const real_t smallp = this->smallp;
-    const real_t smallc = this->smallc;
     const real_t smallr = this->smallr;
     const real_t gval   = this->gval;
   // policy_params is of type Policy::Params which contains an inner member
@@ -219,47 +219,86 @@ Hyperbolic_WellBalanced_RK2(
           auto get_pressure = [&](const PrimState &qleft, const PrimState &qright) {
         
             // Left variables
-            real_t rl = fmax(qleft.rho, smallr);
-            real_t pl = fmax(qleft.p, rl*smallp);
-            real_t ul = (dir == IX ? qleft.u : dir == IY ? qleft.v : qleft.w);
-        
-            real_t ptotl = pl;
-        
-        
-            // Right variables
-            real_t rr = fmax(qright.rho, smallr);
-            real_t pr = fmax(qright.p, rr*smallp);
-            real_t ur = (dir == IX ? qright.u : dir == IY ? qright.v : qright.w);
-        
-            real_t ptotr = pr;
-            
-            // Find the largest eigenvalues in the normal direction to the interface
-            real_t cfastl = SQRT(fmax(gamma0*pl/rl,smallc*smallc));
-            real_t cfastr = SQRT(fmax(gamma0*pr/rr,smallc*smallc));
-        
-            // Compute HLL wave speed
-            real_t SL = fmin(ul,ur) - fmax(cfastl,cfastr);
-            real_t SR = fmax(ul,ur) + fmax(cfastl,cfastr);
-        
-            // Compute lagrangian sound speed
-            real_t rcl = rl*(ul-SL);
-            real_t rcr = rr*(SR-ur);
-            
-            // Compute acoustic star state
-            real_t ustar    = (rcr*ur   +rcl*ul   +  (ptotl-ptotr))/(rcr+rcl);
-            real_t ptotstar = (rcr*ptotl+rcl*ptotr+rcl*rcr*(ul-ur))/(rcr+rcl);
-        
-            real_t ptoto;
-            if (SL > 0)
-              ptoto=ptotl;
-            else if (ustar > 0)
-              ptoto=ptotstar;
-            else if (SR > 0)
-              ptoto=ptotstar;
-            else
-              ptoto=ptotr;
-            return ptoto;
+                const real_t Bx   = 0.5 * (qleft.Bx + qright.Bx) - 0.5/c_h * (qright.psi - qleft.psi);
+
+                // Left variables
+                real_t rl = fmax(qleft.rho, smallr);
+                real_t pl = fmax(qleft.p, rl*smallp);
+                real_t ul =      qleft.u;
+                real_t Byl =     qleft.By;
+                real_t Bzl =     qleft.Bz;
+                real_t B2l =     Bx*Bx+Byl*Byl+Bzl*Bzl;
+                real_t pTl =     pl + 0.5 * B2l;
+
+                // Right variables
+                real_t rr = fmax(qright.rho, smallr);
+                real_t pr = fmax(qright.p, rr*smallp);
+                real_t ur =      qright.u;
+                real_t Byr =     qright.By;
+                real_t Bzr =     qright.Bz;
+                real_t B2r =     Bx*Bx+Byr*Byr+Bzr*Bzr;
+                real_t pTr =     pr + 0.5 * B2r;
+
+                auto computeFastMagnetoAcousticSpeed = [&](const PrimState &q) {
+                  const real_t gp = gamma0 * q.p;
+                  const real_t B2 = Bx*Bx + q.By*q.By + q.Bz*q.Bz;
+                  
+                  return sqrt(0.5 * (gp + B2 + sqrt((gp + B2)*(gp + B2) - 4.0*gp*Bx*Bx)) / q.rho);
+                };
+                
+                
+                real_t cfl = computeFastMagnetoAcousticSpeed(qleft);
+                real_t cfr = computeFastMagnetoAcousticSpeed(qright);
+                
+                // HLL Wave speed
+                real_t Sl = fmin(ul, ur) - fmax(cfl, cfr);
+                real_t Sr = fmax(ul, ur) + fmax(cfl, cfr);
+
+                // Lagrangian speed of sound
+                const real_t rCl = rl*(ul-Sl);
+                const real_t rCr = rr*(Sr-ur);
+
+                // Entropy wave speed
+                const real_t uS = (rCr*ur + rCl*ul - pTr + pTl) / (rCr+rCl);
+                
+                // Single Star state
+                const real_t pTS = (rCr*pTl + rCl*pTr - rCr*rCl*(ur-ul)) / (rCr+rCl); 
+
+                // Single star densities
+                const real_t rlS = rl * (Sl-ul)/(Sl-uS);
+                const real_t rrS = rr * (Sr-ur)/(Sr-uS);
+
+
+                // Alfven wave speeds
+                const real_t srlS = sqrt(rlS);
+                const real_t srrS = sqrt(rrS);
+                const real_t SlS = uS - fabs(Bx) / srlS;
+                const real_t SrS = uS + fabs(Bx) / srrS;
+
+                   
+                // Disjunction of cases
+                real_t p_tot = 0.0;
+                if (Sl > 0.0) { // qL
+                  p_tot = pTl;
+                }
+                else if (SlS > 0.0) { // qL*
+                  p_tot = pTS;
+                }
+                else if (uS > 0.0) { // qL**
+                  p_tot = pTS;
+                }
+                else if (SrS > 0.0) { // qR**
+                  p_tot = pTS;
+                }
+                else if (Sr > 0.0) { // qR*
+                  p_tot = pTS;
+                }
+                else { // SR < 0.0; qR
+                  p_tot = pTr;
+                }
+            return p_tot;
           };
+
           real_t pL=0.0, pR=0.0;
   
           // Compute left side flux
@@ -459,7 +498,7 @@ private:
   typename Policy::Params policy_params;
 
   int ndim;
-  real_t smallr, smallp, smallc, gamma0;
+  real_t smallr, smallp, smallc, smalle, gamma0;
   bool well_balanced_at_boundary;
   bool gravity_enabled;
   real_t gval;
